#include <iostream>
//hw5 14week practice
using namespace std;
//포인트 클래스:좌표에 대한 정보
class Point
{
private:
    int xpos, ypos;
public:
    Point(int x=0, int y=0) : xpos(x), ypos(y) {}
    void show()
    {
        cout << "( " << xpos << ", " << ypos << " )" << endl;
    }
};
//MyStack이라는 템플릿
template <typename T, int len>
class MyStack
{
private:
    int tos; //index
    T data[len]; //T라는 자료형을 담을 수 있는 배열
public:
    MyStack();             //스택생성
    void push(T element); //스택에 저장하는 함수
    T pop();               //스택에서 하나 빼는 함수
};

//템플릿 클래스 함수의 외부정의
template <typename T, int len>
MyStack<T, len>::MyStack()  //생성자
{
    tos = -1;
}

template <typename T, int len>
void MyStack<T, len>::push(T element)
{
    if(tos==(len-1))
    {
        cout << "stack is full" << endl;
        return;
    }
    tos++;
    data[tos] = element;
}

template <typename T, int len>
T MyStack<T, len>::pop()
{
    if(tos==-1)
    {
        cout << "stack is empty" << endl;
        return 0;
    }
    T retData = data[tos];
    tos--;
    return retData;
}
//Point 포인터의 이름을 재정의
typedef Point* POINT_PTR;

int main(void)
{
    MyStack<POINT_PTR*, 100> ppStack; //2중 포인터
    POINT_PTR* pArr = new POINT_PTR[3]; //1중 포인터
    POINT_PTR* qArr;
    for(int i=0; i<3; i++){
        pArr[i] = new Point(i,i+1); //동적할당시에 생성된 Point의 주소값 전달
    }
    ppStack.push(pArr);
    qArr = ppStack.pop();
    for(int i=0; i<3; i++){
        qArr[i]->show(); //qArr은 포인터라 출력할때도 ->
    }
    delete [] pArr;
    return 0;
}
